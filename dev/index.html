<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OptimalMappings.jl · OptimalMappings.jl</title><meta name="title" content="OptimalMappings.jl · OptimalMappings.jl"/><meta property="og:title" content="OptimalMappings.jl · OptimalMappings.jl"/><meta property="twitter:title" content="OptimalMappings.jl · OptimalMappings.jl"/><meta name="description" content="Documentation for OptimalMappings.jl."/><meta property="og:description" content="Documentation for OptimalMappings.jl."/><meta property="twitter:description" content="Documentation for OptimalMappings.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>OptimalMappings.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>OptimalMappings.jl</a><ul class="internal"><li><a class="tocitem" href="#Example-1"><span>Example 1</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>OptimalMappings.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OptimalMappings.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ToBlick/OptimalMappings.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ToBlick/OptimalMappings.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OptimalMappings.jl"><a class="docs-heading-anchor" href="#OptimalMappings.jl">OptimalMappings.jl</a><a id="OptimalMappings.jl-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalMappings.jl" title="Permalink"></a></h1><p>This package contains the code used in the numerical examples of <a href="https://arxiv.org/abs/2304.14884">arXiv:2304.14884</a>. It relies on <a href="https://github.com/gridap/Gridap.jl">Gridap.jl</a> for finite element routines and <a href="https://github.com/JuliaRCM/OptimalTransportTools.jl">OptimalTransportTools.jl</a> for computational optimal transport.</p><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example 1</a><a id="Example-1-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>The equation to solve reads  <span>$\Delta u(x; \mu) = f(x; \mu) : x \in \Omega, u(x; \mu) = 0 : x \in \partial \Omega.$</span></p><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>We begin by setting the hyperparameters: the entropic regulaization strength and the eigenvalue energy tolerance being the most important.</p><pre><code class="language-julia hljs">const ε = 1e-2
const τ = 1e-4
const τ_eim = 0.1τ
const δ⁻¹ = 1e9
const κ = 1 / sqrt(ε)
const debias = true</code></pre><p>Then, we define the PPDE problem and set up the needed FE spaces.</p><pre><code class="language-julia hljs">const nₛ = 50
const nₜ = 25
const μ_min = -0.35
const μ_max = 0.35
const var = 1e-3
P = PoissonProblem(var)
f(x, x0) = exp(-((x[1] - x0[1])^2 + (x[2] - x0[2])^2) / 2 / P.var) / (2π * P.var)</code></pre><pre><code class="language-julia hljs">const d = 2
const N = 32
const highorder = 3
const N_fine = highorder * N
const ε_fine = 0.1 / N^2
fe_spaces = initialize_fe_spaces(N, N_fine, d, highorder, P)
dΩ = fe_spaces.dΩ</code></pre><h3 id="Training-and-testing-data"><a class="docs-heading-anchor" href="#Training-and-testing-data">Training and testing data</a><a id="Training-and-testing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Training-and-testing-data" title="Permalink"></a></h3><p>We compute the training snapshots <span>$u(\mu_i) \; \forall i = 1, \dots, n_s$</span></p><pre><code class="language-julia hljs">μ_train = testparameterset(nₛ, μ_max, μ_min)
uE_train = [snapshot(f, μ, fe_spaces.V, fe_spaces.U, dΩ, P) for μ in μ_train]
u_train = [uE[1] for uE in uE_train]
E_train = [uE[2] for uE in uE_train]</code></pre><p>and the test set.</p><pre><code class="language-julia hljs">μ_test = testparameterset(nₜ, μ_max, μ_min)
uE_test = [snapshot(f, μ, fe_spaces.V, fe_spaces.U, dΩ, P) for μ in μ_test]
u_test = [uE[1] for uE in uE_test]
E_test = [uE[2] for uE in uE_test]</code></pre><h3 id="Reduced-basis"><a class="docs-heading-anchor" href="#Reduced-basis">Reduced basis</a><a id="Reduced-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Reduced-basis" title="Permalink"></a></h3><p>The reduced basis without registration <span>$\zeta_1, \dots, \zeta_n$</span></p><pre><code class="language-julia hljs">ζ, evd_u = pod(u_train, fe_spaces.V, fe_spaces.U, dΩ, τ)
n = length(ζ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">41</code></pre><p>is used solve the reduced problem without registration.</p><pre><code class="language-julia hljs">Aᵣ = OptimalMappings.get_A(μ_train[1], ζ, dΩ)
ũE_rb = [snapshot(f, μ, fe_spaces.V, fe_spaces.U, dΩ, ζ, Aᵣ, P) for μ in μ_test]
ũ_rb = [uE[1] for uE in ũE_rb]
E_rb = [uE[2] for uE in ũE_rb]
u_rb = [FEFunction(fe_spaces.V, u&#39; * get_free_dof_values.(ζ)) for u in ũ_rb]</code></pre><h3 id="Optimal-transport-calculations"><a class="docs-heading-anchor" href="#Optimal-transport-calculations">Optimal transport calculations</a><a id="Optimal-transport-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-transport-calculations" title="Permalink"></a></h3><p>The choice for <span>$\rho$</span> is <span>$\rho(\mu) := \tfrac{u(\mu)^2}{\int u(\mu)^2}$</span>. The reference density <span>$\bar \rho$</span> is the (unweighted) OT barycenter. </p><pre><code class="language-julia hljs">c = OptimalTransportTools.get_cost_matrix_separated(N_fine+1, d, a=[fe_spaces.domain[1] fe_spaces.domain[3]], b=[fe_spaces.domain[2] fe_spaces.domain[4]])
k = OptimalTransportTools.get_gibbs_matrix(c, ε)
MC = MatrixCache(N_fine + 1)
ρ(u) = u ⋅ u
ρ̂_train = [get_ρ̂(u, ρ, fe_spaces.V_fine, N_fine + 1) for u in u_train]
SP = SinkhornParameters(Int(10 * ceil(1 / ε)), ε, 1e-3, false, debias, true)
ρ̂_ref = sinkhorn_barycenter_sep([1 / nₛ for _ in ρ̂_train], ρ̂_train, k, SP, MC)
log_ρ̂_ref = safe_log.(ρ̂_ref)
ρ_ref = interpolate_everywhere(Interpolable(FEFunction(fe_spaces.V_fine, vec(ρ̂_ref))), fe_spaces.Ψ);</code></pre><h3 id="Transport-modes"><a class="docs-heading-anchor" href="#Transport-modes">Transport modes</a><a id="Transport-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Transport-modes" title="Permalink"></a></h3><p>Next, the transport potentials <span>$\psi^c_i$</span> between <span>$\bar \rho$</span> and all <span>$\rho(\mu_i)$</span> are computed. The boundary projection guarantees that <span>$y \mapsto y - \nabla \psi^c_i(y)$</span> is orthogonal to the domain boundary.</p><pre><code class="language-julia hljs">ψ̂ᶜ = [get_ψ̂_ψ̂ᶜ(ρ̂, ρ̂_ref, k, SP, MC)[2] for ρ̂ in ρ̂_train];
ψᶜ = [boundary_projection(ψᶜ, δ⁻¹, κ, fe_spaces.Ψ, dΩ, 2 * highorder) for ψᶜ in ψ̂ᶜ]</code></pre><p>The transport modes <span>$\xi^c_j$</span> are obtained by performing a proper orthogonal decomposition on the transport maps as elements of the tangent space of <span>$\mathcal P$</span> at <span>$\bar \rho$</span>.</p><pre><code class="language-julia hljs">ξᶜ, evd_ψᶜ = pod_monge_embedding(ψᶜ, ρ_ref, fe_spaces.Ψ, fe_spaces.Ψ, dΩ, τ)
m = length(ξᶜ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7</code></pre><pre><code class="language-julia hljs">plot(ξᶜs...)</code></pre><img src="index-fa0ad8bc.svg" alt="Example block output"/><h3 id="The-\\mu-\\mapsto-\\Phi{-1}_\\mu-map"><a class="docs-heading-anchor" href="#The-\\mu-\\mapsto-\\Phi{-1}_\\mu-map">The <span>$\mu \mapsto \Phi^{-1}_\mu$</span> map</a><a id="The-\\mu-\\mapsto-\\Phi{-1}_\\mu-map-1"></a><a class="docs-heading-anchor-permalink" href="#The-\\mu-\\mapsto-\\Phi{-1}_\\mu-map" title="Permalink"></a></h3><p>The mapping <span>$\Phi^{-1}_\mu: y \mapsto y - \sum_j w(\mu)_j \nabla \xi^c_j(y)$</span> is determined by the weights <span>$w_j(\mu)$</span>, which are the output of a Gaussian process, fitted to the training data.</p><pre><code class="language-julia hljs">w = [[sum(∫(∇(_ψᶜ) ⋅ ∇(_ξᶜ) * ρ_ref)dΩ) for _ξᶜ in ξᶜ] for _ψᶜ in ψᶜ]
ψᶜ_train = [FEFunction(fe_spaces.Ψ, _w&#39; * get_free_dof_values.(ξᶜ)) for _w in w]
μ_mat = [μ[k] for k in 1:d, μ in μ_train]
gp = get_gp(μ_mat, w, m);</code></pre><pre><code class="language-julia hljs">plot(ws...)</code></pre><img src="index-68a13057.svg" alt="Example block output"/><h3 id="Reference-reduced-basis"><a class="docs-heading-anchor" href="#Reference-reduced-basis">Reference reduced basis</a><a id="Reference-reduced-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-reduced-basis" title="Permalink"></a></h3><p>With the constructed mappings <span>$\Phi^{-1}_\mu$</span>, we map the solutions from the training set and construct a reduced basis.</p><pre><code class="language-julia hljs">T★u_train = [pushfwd(u_train[i], ψᶜ_train[i], fe_spaces.V, dΩ) for i in eachindex(u_train)]
ϕ, evd_T★u = pod(T★u_train, fe_spaces.V, fe_spaces.U, dΩ, τ)
nₘ = length(ϕ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><p>The mapped snapshots are much easier to compress using linear methods as indicated by the decay of the correlation matrix eigenvalues.</p><pre><code class="language-julia hljs">plot(evds)</code></pre><img src="index-b22aab6e.svg" alt="Example block output"/><h3 id="Empirical-interpolation"><a class="docs-heading-anchor" href="#Empirical-interpolation">Empirical interpolation</a><a id="Empirical-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Empirical-interpolation" title="Permalink"></a></h3><p>To construct the empirical iterpolation, we collect the parameter-dependent forms from the training set and perform a proper orthogonal decomposition. The interpolation functions and points are then obtained starting from these POD modes. </p><pre><code class="language-julia hljs">f★J = [get_f★J(f, μ, get_transport_potential(μ, ξᶜ, fe_spaces.Ψ, gp), fe_spaces.W) for μ in μ_train]
Ξ_f★J, evd_f★J = pod(f★J, fe_spaces.W, fe_spaces.W, dΩ, τ_eim)
eim_f★J = EmpiricalInterpolation(Ξ_f★J, (ϕ,X) -&gt; form_f★J(ϕ,X,dΩ), ϕ, fe_spaces.W)
K = [get_K(get_transport_potential(μ, ξᶜ, fe_spaces.Ψ, gp), fe_spaces.W_matrix) for μ in μ_train];
Ξ_K, evd_K = pod(K, fe_spaces.W_matrix, fe_spaces.W_matrix, dΩ, τ_eim)
eim_K = EmpiricalInterpolation(Ξ_K, (ϕ,X) -&gt; form_K(ϕ,X,dΩ), ϕ, fe_spaces.W_matrix)
get_Q(eim_K), get_Q(eim_f★J)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(17, 22)</code></pre><pre><code class="language-julia hljs">plot(eim_evds)</code></pre><img src="index-008934ac.svg" alt="Example block output"/><h3 id="Online-phase"><a class="docs-heading-anchor" href="#Online-phase">Online phase</a><a id="Online-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Online-phase" title="Permalink"></a></h3><p>The online phase consists of evaluating the <span>$\mu \mapsto w(\mu)_j$</span> maps and solving the mapped problem in the reference reduced basis. Lastly, the solution is mapped back for plotting using the c-transform.</p><pre><code class="language-julia hljs">ψᶜ_test = [get_transport_potential(μ, ξᶜ, fe_spaces.Ψ, gp) for μ in μ_test]
ũE_trb_eim = [snapshot(f, μ_test[i], fe_spaces.V, fe_spaces.U, dΩ, ϕ, ψᶜ_test[i], eim_f★J, eim_K, P) for i in eachindex(μ_test)];</code></pre><pre><code class="language-julia hljs">T★u_trb_eim = [FEFunction(fe_spaces.V, uE[1]&#39; * get_free_dof_values.(ϕ)) for uE in ũE_trb_eim]
E_trb_eim = [uE[2] for uE in ũE_trb_eim]
ψ̂_test = [c_transform(ψᶜ, fe_spaces.V_fine, c, log_ρ̂_ref, MC, ε_fine) for ψᶜ in ψᶜ_test]
ψ_test = [boundary_projection(ψ, δ⁻¹, κ, fe_spaces.Ψ, dΩ, 2 * highorder) for ψ in ψ̂_test]
u_trb_eim = [pushfwd(T★u_trb_eim[i], ψ_test[i], fe_spaces.V, dΩ) for i in eachindex(μ_test)]
ΔL2_trb_eim = rel_error_vec(u_trb_eim, u_test, L2, dΩ)
@printf &quot;registered (n = %.0f, m = %.0f) \t L2 error avg.: %.2e ± %.2e \t max.: %.2e \n&quot; nₘ m Statistics.mean(ΔL2_trb_eim) Statistics.std(ΔL2_trb_eim) maximum(ΔL2_trb_eim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">registered (n = 8, m = 7) 	 L2 error avg.: 2.34e-02 ± 1.31e-02 	 max.: 5.35e-02</code></pre><p>Lastly, we plot some cross-sections of the worst approximation.</p><pre><code class="language-julia hljs">plot(cross_sec_1, cross_sec_2)</code></pre><img src="index-b1c9adc3.svg" alt="Example block output"/></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 13 March 2024 13:52">Wednesday 13 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
